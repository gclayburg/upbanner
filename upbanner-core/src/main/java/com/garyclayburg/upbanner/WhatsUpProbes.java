package com.garyclayburg.upbanner;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.InetAddress;
import java.net.URLClassLoader;
import java.net.UnknownHostException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.time.DateTimeException;
import java.time.Instant;
import java.util.*;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.garyclayburg.upbanner.jarprobe.JarProbe;
import com.garyclayburg.upbanner.oshiprobe.OshiProbe;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.info.BuildProperties;
import org.springframework.context.ApplicationContext;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.EnumerablePropertySource;
import org.springframework.core.env.Environment;

/**
 * <br><br>
 * Created 2020-06-09 10:41
 *
 * @author Gary Clayburg
 */
public class WhatsUpProbes {

    public static final String MEM_TOTAL_REGEX = "^MemTotal:\\s*(\\d+)\\s*kB.*$";
    public static final Pattern MEM_TOTAL_REGEX_PATTERN = Pattern.compile(MEM_TOTAL_REGEX);
    public static final int DEFAULT_VALUE = -42;
    public static final String DEFAULT_VALUE_STRING = "";
    public static final String CGROUP_FILE = "/proc/self/cgroup";
    private final OshiProbe oshiProbe;
    private final JarProbe jarProbe;
    private final UpbannerSettings upbannerSettings;
    private ApplicationContext context;
    protected ConfigurableEnvironment environment;
    protected BuildProperties buildProperties;

    @SuppressWarnings("UnusedDeclaration")
    private static final Logger log = LoggerFactory.getLogger(WhatsUpProbes.class);
    private String applicationName;
    protected int listeningPort;
    private Properties gitProperties;
    private boolean gitPropertiesLoaded;
    private final List<ExtraLinePrinter> extraLinePrinterList;

    public WhatsUpProbes(ConfigurableEnvironment environment, BuildProperties buildProperties, OshiProbe oshiProbe, JarProbe jarProbe, UpbannerSettings upbannerSettings, ApplicationContext context) {
        this.environment = environment;
        this.buildProperties = buildProperties;
        this.oshiProbe = oshiProbe;
        this.jarProbe = jarProbe;
        this.upbannerSettings = upbannerSettings;
        this.context = context;
        this.gitProperties = null;
        this.gitPropertiesLoaded = false;
        this.listeningPort = 0;
        extraLinePrinterList = new ArrayList<>();
    }

    protected Properties loadGitProperties() {
        if (!this.gitPropertiesLoaded) {
            this.gitPropertiesLoaded = true;
            this.gitProperties = new Properties();
            ClassLoader classLoader = this.getClass().getClassLoader();
            InputStream resourceAsStream = classLoader.getResourceAsStream("git.properties");
            if (resourceAsStream != null) {
                try {
                    gitProperties.load(resourceAsStream);
                } catch (IOException e) {
                    log.warn("Cannot load git.properties " + e.getMessage());
                }
            } else {
                log.debug("Cannot display git status - git.properties not found in classpath");
            }
        }
        return gitProperties;
    }

    /**
     * @return "http" if the web app can be access using http, or "https" if the app has been configured to use https protocol
     */
    public String getProtocol() {
        String retval = "http";
        String secure = getEnvironmentProperty("security.require-ssl");
        if (secure != null && secure.equals("true")) {
            retval = "https";
        }
        return retval;
    }

    /**
     * This generates a string to represent the name and version of your app
     * <p>
     * For example,
     * <blockquote><pre>
     * My Great App:0.0.1
     * Demo:2.0-SNAPSHOT
     * synconsole:0.8.3-RELEASE
     * </pre></blockquote>
     * The result is formatted as name:version.
     * <p>Both the {@linkplain #getAppName() name} and the version portion is generated by probing the context of
     * the running app. For version, these sources are searched.  The first one present
     * wins:
     * <pre>
     * spring property key info.app.version
     * build-info.properties key build.version
     * git.properties key git.build.version
     * jar file manifest key Implementation-Version
     * </pre>
     * <p>
     * If no version is found, only the {@linkplain #getAppName() name} is returned
     *
     * @return name:version of the running application
     * @see #getAppName()
     */
    public String getAppNameVersion() {
        String name = getAppName();

        String version = getEnvironmentProperty("info.app.version");
        if (version == null) {
            version = buildProperties.getVersion();
            if (version == null) {
                version = getEnvironmentProperty("git.build.version");
                if (version == null) {
                    Manifest manifest = jarProbe.getManifest();
                    if (manifest != null) {
                        version = manifest.getMainAttributes().getValue("Implementation-Version");
                    }
                }
            }
        }
        if (version != null) {
            name += ":" + version;
        }
        return name;
    }

    /**
     * This probes the context of the running application to determine the name.
     * It does this by looking at a few well-known places.  The first one to
     * return a value wins.
     * <pre>
     *     1. spring external property: spring.application.name
     *     2. application name returned by Spring Boot via {@link org.springframework.boot.SpringApplicationRunListener}
     *     3. A name generated by examining "java.sun.command" env and "Start-Class" from the manifest
     *     4. The generic name "Application"
     * </pre>
     * <p>In most cases, the name is satisfied from one of the first 2 steps.
     * However, the name from step 2 above will not exist until the application is
     * completely up and running.  Meaning, the spring context has been loaded and
     * the app has started.  This corresponds to the finished phase of a Spring boot
     * 1.x app or the started phase of a Spring boot 2.x app
     * <p>In the case of #3 above, it knows the structure of a Spring boot app and
     * the many ways it could have been started, e.g.
     * <pre>
     * $ java -jar myapp.jar
     * $ java -jar myapp.war
     * $ ./gradlew bootRun
     * $ mvn spring-boot:run
     * exploded jar
     * exploded war
     * running from within an IDE, i.e. not from any jar or war
     * running inside a docker container
     * </pre>
     * Regardless of how the app is started, the name returned should be consistent.
     *
     * @return the name of the running spring boot application, or "Application" if the name is unknown
     */
    public String getAppName() {
        String name = getEnvironmentProperty("spring.application.name");
        if (name == null) {
            name = applicationName;
            if (applicationName == null) {
                name = getMain("Application");
            }
        }
        return name;
    }

    String getMain(String name) {
        String javaCommand = System.getProperty("sun.java.command");
        if (javaCommand != null) {
            name = getMainStart(javaCommand);
        }
        return name;
    }

    String getMainStart(String javaCommand) {
        String name = "Application";
        String mainName = convertSunJavaCommand(javaCommand);
        if (javaCommand.contains("JarLauncher") || javaCommand.contains("WarLauncher")) {
            // we are running a spring boot jar or expanded jar.
            // Start-Class attribute from the expanded Manifest file
            // has the real class that will be executed first
            name = extractStartClassName(name);
        } else if (mainName != null) {
            if (mainName.equals("jar")) {
                //we could be running a spring boot bundled jar OR something more
                // opaque like surefire test runner
                name = extractStartClassName(name);
            } else {
                //e.g. com.garyclayburg.synconsole.SynconsoleApp -> SynconsoleApp
                name = mainName;
            }
        }
        return name;
    }

    private String extractStartClassName(String mainName) {
        Manifest manifest = jarProbe.getManifest();
        if (manifest != null) {
            Attributes mainAttributes = manifest.getMainAttributes();
            if (log.isDebugEnabled()) {
                StringBuilder stringBuilder = new StringBuilder();
                jarProbe.showManifest(stringBuilder, manifest);
                log.debug("root manifest found is: " + System.lineSeparator() + stringBuilder);
            }
            String startClassName = mainAttributes.getValue("Start-Class");
            log.debug(" start class is " + startClassName);
            if (startClassName != null) {
                mainName = convertStartClass(startClassName);
            }
        }
        return mainName;
    }

    String convertSunJavaCommand(String javaCommand) {
        // javaCommand when running specified java main in IntelliJ:
        // com.garyclayburg.BootUp

        // javaCommand when running testClass via IntelliJ:
        // com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.example.demo.DemoApplicationTests

        // javaCommand when running testClass via maven:
        // /home/gclaybur/dev/gvsync/upbanner/webjar244/target/surefire/surefirebooter2001082309298668663.jar /home/gclaybur/dev/gvsync/upbanner/webjar244/target/surefire 2021-03-22T08-45-40_408-jvmRun1 surefire5666214610931227172tmp surefire_04846830553387518722tmp

        // javaCommand when running testClass via gradle:
        // worker.org.gradle.process.internal.worker.GradleWorkerMain 'Gradle Test Executor 2'

        // javaCommand when running as standalone jar like this:  java -jar ./webjar244/target/demo-2.1.2-SNAPSHOT.jar
        // ./webjar244/target/demo-2.1.2-SNAPSHOT.jar
        log.debug("javaCommand is: " + javaCommand);
        String stripped = javaCommand.replaceFirst(" .*$", "");
        return convertStartClass(stripped);
    }

    String convertStartClass(String startClassName) {
        if (startClassName != null) {
            String[] split = startClassName.split("\\.");
            return split[split.length - 1];
        }
        return null;
    }

    protected String getBuildProp(String key) {
        String retval = "unknown";
        if (buildProperties.get(key) != null) {
            retval = buildProperties.get(key);
        }
        return retval;
    }

    /**
     * @param key the name of the Spring property key, e.g. "server.port" or "spring.application.name"
     * @return a String value from the Spring {@link Environment} or "" if the key does not exist or the value is corrupt
     * @see #getEnvironmentProperty(String)
     */
    public String getEnvironmentPropertyPrintable(String key) {
        String value = "";
        try {
            value = environment.getProperty(key);
            if (value == null) {
                value = "";
            }
        } catch (IllegalArgumentException ignored) { //i.e. it may need to be filtered first through build.gradle
        }
        return value;
    }

    /**
     * @param key the name of the Spring property key, e.g. "server.port" or "spring.application.name"
     * @return a String value from the Spring {@link Environment} or null if the key does not exist
     * @see #getEnvironmentPropertyPrintable(String)
     */
    public String getEnvironmentProperty(String key) {
        String value = null;
        try {
            value = environment.getProperty(key);
        } catch (IllegalArgumentException ignored) {
        }
        return value;
    }

    /**
     * Prints the environment in which this app is running to the log system (console)
     * We attempt to print this information as soon as possible during application startup
     */
    public void dumpAll() {
        dumpAll(stringBuilder -> {
        });
    }

    public void dumpAll(ExtraLinePrinter extraLinePrinter) {
        if (upbannerSettings.isDebug()) {
            StringBuilder probe = new StringBuilder();
            section(probe, "\n===== What OS and hardware are we running on =====");
            oshiProbe.createReport(probe);
            section(probe, "\n===== What OS resources are limited ==============");
            dumpCPUlimits(probe);
            dumpMemoryLimits(probe);
            section(probe, "\n===== What environment are we running with =======");
//            dumpSystemProperties(probe);
//            dumpENV(probe);
            dumpPropertySources(probe);
            section(probe, "\n===== How was it built ===========================");
            dumpBuildProperties(probe);
            section(probe, "\n===== How was it started =========================");
            jarProbe.init(probe);
            dumpStartupCommandJVMargs(probe);
            section(probe, "\n===== What is running ============================");
            dumpGitProperties(probe);
            jarProbe.createRootManifestReport(probe);
            jarProbe.createSnapshotJarReport(probe);
            extraLinePrinter.call(probe);
            if (log.isInfoEnabled()) {
                log.info("Environment probe:" + System.lineSeparator() + probe);
            } else { // the operator wants to show the information.  Lets not also force them to enable INFO
                log.warn("INFO logging is disabled. showing requested debug info as WARN instead");
                log.warn("Environment probe:" + System.lineSeparator() + probe);
            }
        }
    }

    protected void section(StringBuilder probeOut, String header) {
        probeOut.append(header).append(System.lineSeparator());
    }

    public void dumpCPUlimits(StringBuilder probeOut) {
        probeOut.append("  CPU limits").append(System.lineSeparator());
        probeOut.append("available logical processors: ").append(Runtime.getRuntime().availableProcessors())
                .append(System.lineSeparator());
        CgroupCpuStats cgroupCpuStats = new CgroupCpuStats();
        cgroupCpuStats.setCfs_period_us(readLong(DEFAULT_VALUE, "/sys/fs/cgroup/cpu/cpu.cfs_period_us"));
        if (cgroupCpuStats.getCfs_period_us() != DEFAULT_VALUE) {
            probeOut.append("cfs_period_us: ").append(cgroupCpuStats.getCfs_period_us())
                    .append(System.lineSeparator());
        }
        cgroupCpuStats.setCfs_quota_us(readLong(DEFAULT_VALUE, "/sys/fs/cgroup/cpu/cpu.cfs_quota_us"));
        if (cgroupCpuStats.getCfs_quota_us() != DEFAULT_VALUE) {
            probeOut.append("cpu.cfs_quota_us: ").append(cgroupCpuStats.getCfs_quota_us())
                    .append(System.lineSeparator());
        }
        cgroupCpuStats.setCpu_shares(readLong(DEFAULT_VALUE, "/sys/fs/cgroup/cpu,cpuacct/cpu.cpu_shares"));
        if (cgroupCpuStats.getCpu_shares() != DEFAULT_VALUE) {
            probeOut.append("cpu.shares: ").append(cgroupCpuStats.getCpu_shares())
                    .append(System.lineSeparator());
        }
        cgroupCpuStats.setCpuacct_usage(readLong(DEFAULT_VALUE, "/sys/fs/cgroup/cpu,cpuacct/cpuacct.usage"));
        if (cgroupCpuStats.getCpuacct_usage() != DEFAULT_VALUE) {
            probeOut.append("cpuacct.usage: ").append(cgroupCpuStats.getCpuacct_usage() / 1000.0 / 1000.0 / 1000.0)
                    .append(System.lineSeparator());
        }
        cgroupCpuStats.setCpuacct_usage_percpu(readString(DEFAULT_VALUE_STRING, "/sys/fs/cgroup/cpu,cpuacct/cpuacct.usage_percpu"));
        if (!cgroupCpuStats.getCpuacct_usage_percpu().equals(DEFAULT_VALUE_STRING)) {
            probeOut.append("cpuacct.usage_percpu: ").append(cgroupCpuStats.getCpuacct_usage_percpu())
                    .append(System.lineSeparator());
        }
        cgroupCpuStats.setCpuset(readString(DEFAULT_VALUE_STRING, "/sys/fs/cgroup/cpuset/cpuset.cpus"));
        if (!cgroupCpuStats.getCpuset().equals(DEFAULT_VALUE_STRING)) {
            probeOut.append("cpuset: ").append(cgroupCpuStats.getCpuset())
                    .append(System.lineSeparator());
        }

        File cpustat = new File("/sys/fs/cgroup/cpu/cpu.stat");
        if (cpustat.canRead()) {
            try (BufferedReader br = new BufferedReader(new FileReader(cpustat))) {
                String line = br.readLine();
                while (line != null) {
                    Pattern NR_PERIODS_P = Pattern.compile("^nr_periods\\s+(\\d+)$");
                    Matcher m = NR_PERIODS_P.matcher(line);
                    if (m.find()) {
                        cgroupCpuStats.setNr_periods(Long.parseLong(m.group(1)));
                        probeOut.append("nr_periods: ").append(cgroupCpuStats.getNr_periods())
                                .append(System.lineSeparator());
                    }

                    Pattern NR_THROTTLDED_P = Pattern.compile("^nr_throttled\\s+(\\d+)$");
                    Matcher mt = NR_THROTTLDED_P.matcher(line);
                    if (mt.find()) {
                        cgroupCpuStats.setNr_throttled(Long.parseLong(mt.group(1)));
                        probeOut.append("nr_throttled: ").append(cgroupCpuStats.getNr_throttled())
                                .append(System.lineSeparator());
                    }

                    Pattern THROTTLED_TIME_P = Pattern.compile("^throttled_time\\s+(\\d+)$");
                    Matcher mtt = THROTTLED_TIME_P.matcher(line);
                    if (mtt.find()) {
                        cgroupCpuStats.setThrottled_time(Long.parseLong(mtt.group(1)));
                        probeOut.append("throttled_time: ").append(cgroupCpuStats.getThrottled_time())
                                .append(System.lineSeparator());
                    }

                    line = br.readLine();
                }
            } catch (IOException ignored) {

            }
        }
    }

    private String readString(String defaultValue, String pathname) {
        File file = new File(pathname);
        if (file.canRead()) {
            try (BufferedReader br = new BufferedReader(new FileReader(file))) {
                defaultValue = br.readLine();
            } catch (IOException ignored) {
            }
        }
        return defaultValue;
    }

    private long readLong(long defaultValue, String pathname) {
        try {
            defaultValue = Long.parseLong(readString("", pathname));
        } catch (NumberFormatException ignored) {
        }
        return defaultValue;
    }

    public void dumpMemoryLimits(StringBuilder probeOut) {
        /*
        Todo: add additional checks for cgroup cpu limitation
        https://fabiokung.com/2014/03/13/memory-inside-linux-containers/
        Are there environment variables CONTAINER_MAX_MEMORY and CONTAINER_MAX_CPU or MAX_CORE_LIMIT available?

Files relevant to container limits:
cores:
cpu_period_file="/sys/fs/cgroup/cpu/cpu.cfs_period_us"
cpu_quota_file="/sys/fs/cgroup/cpu/cpu.cfs_quota_us"
memory:
mem_file="/sys/fs/cgroup/memory/memory.limit_in_bytes"
         */
        probeOut.append("\n  JVM memory limits").append(System.lineSeparator());
        probeOut.append(String.format("JVM heap free memory:  %15s (%sm)",
                Runtime.getRuntime().freeMemory(),
                Runtime.getRuntime().freeMemory() / 1024 / 1024))
                .append(System.lineSeparator());
        probeOut.append(String.format("JVM heap total memory: %15s (%sm)",
                Runtime.getRuntime().totalMemory(),
                Runtime.getRuntime().totalMemory() / 1024 / 1024))
                .append(System.lineSeparator());
        probeOut.append(String.format("JVM heap max memory:   %15s (%sm)",
                Runtime.getRuntime().maxMemory(),
                Runtime.getRuntime().maxMemory() / 1024 / 1024))
                .append(System.lineSeparator());
        long jvmMaxMemoryKb = Runtime.getRuntime().maxMemory() / 1024;
        File file = Paths.get("/sys/fs/cgroup/memory/memory.limit_in_bytes").toFile();
        String memoryLimitInBytes = "unknown";
        String memoryLimitMB = "unknown";
        long cgroupsMemLimitKb = Long.MAX_VALUE;
        try (BufferedReader br = new BufferedReader(new FileReader(file))) {
            if (file.canRead()) {

                memoryLimitInBytes = br.readLine();
                long memLimitMB = Long.parseLong(memoryLimitInBytes) / 1024 / 1024;
                cgroupsMemLimitKb = Long.parseLong(memoryLimitInBytes) / 1024;
                memoryLimitMB = String.valueOf(memLimitMB);
            }
        } catch (IOException ignored) {
        }
        File procMeminfo = new File("/proc/meminfo");
        long memTotalKbLong = Long.MAX_VALUE;
        try (BufferedReader br = new BufferedReader(new FileReader(procMeminfo))) {
            if (procMeminfo.canRead()) {
                String memTotalKb = br.lines()
                        .filter(line -> line.matches(MEM_TOTAL_REGEX))
                        .map(line -> {
                            Matcher m = MEM_TOTAL_REGEX_PATTERN.matcher(line);
                            String memKb = "";
                            if (m.find()) {
                                memKb = m.group(1);
                            }
                            return memKb;
                        })
                        .reduce("", (a, b) -> b);
                memTotalKbLong = Long.parseLong(memTotalKb);
                probeOut.append(String.format("OS Memory installed: %17s (%sm)",
                        memTotalKbLong * 1024,
                        memTotalKbLong / 1024)).append(System.lineSeparator());
            }
        } catch (IOException ignored) {
        }
        if (cgroupsMemLimitKb >= memTotalKbLong) { //no mem limit imposed on our cgroup
            probeOut.append("cgroups memory limit:        unlimited").append(System.lineSeparator());
        } else { // our container was started with limited memory
            if (cgroupsMemLimitKb < jvmMaxMemoryKb) {
                log.warn(String.format("cgroups memory limit:  %15s (%sm)", memoryLimitInBytes, memoryLimitMB));
                log.warn("JVM max heap size is too big for our cgroup." + System.lineSeparator() +
                         "  This JVM will likely become unstable under memory pressure, i.e.," + System.lineSeparator() +
                         "  the kernel could rudely kill the JVM if it requests too much memory. ");
            } else {
                probeOut.append(String.format("cgroups memory limit:  %15s (%sm)",
                        memoryLimitInBytes, memoryLimitMB)).append(System.lineSeparator());
            }
        }
    }

    /**
     * convert stored time to Instant<br>
     * We don't rely on {@link BuildProperties} class to convert this because
     * BuildProperties has a different API dealing with Date and Time
     * between Spring Boot version 1.x and 2.x.  We want upbanner
     * to work with either.
     *
     * @param key name of key that holds a time value in milliseconds
     * @return Instant
     */
    Instant getInstant(String key) {
        String time = buildProperties.get(key);
        if (time != null) {
            try {
                return Instant.ofEpochMilli(Long.parseLong(time));
            } catch (NumberFormatException ignored) {
                // Not valid epoch time
            } catch (DateTimeException ignored) {
            }
        }
        return null;
    }

    public void dumpBuildProperties(StringBuilder probeOut) {
        probeOut.append("  build-info.properties dump").append(System.lineSeparator());
        formatBuildTime(probeOut);
        if (buildProperties.getVersion() != null && !buildProperties.getVersion().equals("development build")) {
            buildProperties.forEach(prop -> probeOut.append("buildprop ").append(prop.getKey()).append(": ").append(prop.getValue()).append(System.lineSeparator()));
        }
    }

    private void formatBuildTime(StringBuilder probeOut) {
        //"time" will be stored differently when running under spring boot 1.x, compared to spring boot 2.x
        // The Spring Boot 1.x BuildProperties has a bug where it does not store time as millis,
        // even though it tries.  The result is that time is stored as a human readable form.
        // Spring Boot 2.x does parse the time correctly into millis, so this value must be formatted
        // to be human readable.
        Instant time = getInstant("time");
        if (time != null) {
            try {
                Date date = Date.from(time);
                SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ssZ");

                probeOut.append("build time: ").append(formatter.format(date)).append(System.lineSeparator());
            } catch (IllegalArgumentException ignored) {
                // this is not the build time you were looking for anyway.
            }
        }
    }

    public void dumpGitProperties(StringBuilder probeOut) {
        probeOut.append("  git.properties dump").append(System.lineSeparator());
        loadGitProperties().forEach((k, v) -> probeOut.append("gitprop ").append(k).append(": ").append(v).append(System.lineSeparator()));
    }

    public void dumpSystemProperties(StringBuilder probeOut) {
        probeOut.append("  system properties dump").append(System.lineSeparator());
        try {
            System.getProperties().stringPropertyNames().stream().sorted().forEach(name ->
                    probeOut.append("prop ").append(name).append(": ")
                            .append(System.getProperty(name))
                            .append(System.lineSeparator())
            );
        } catch (SecurityException ignored) {
            probeOut.append("WARN - access to properties blocked by Security Manager");
        }
    }

    public void dumpENV(StringBuilder probeOut) {
        probeOut.append(System.lineSeparator())
                .append("  system environment dump").append(System.lineSeparator());
        try {
            System.getenv().keySet().stream().sorted().forEach(name ->
                    probeOut.append("env ").append(name).append(": ")
                            .append(System.getenv(name))
                            .append(System.lineSeparator()));
        } catch (SecurityException ignored) {
            probeOut.append("WARN - access to env blocked by Security Manager");
        }
    }

    /*
===== What environment are we running with =======
----- configurationProperties [no enumerable properties]-----
----- commandLineArgs -----
server.port=2345
upbanner.debug=true
----- servletConfigInitParams [no enumerable properties] -----
     */
    public void dumpPropertySources(StringBuilder probe) {
        List<String> knownPropertyNames = new ArrayList<>();
        environment.getPropertySources().forEach(propertySource -> {
            if (propertySource instanceof EnumerablePropertySource) {
                probe.append("---- ").append(propertySource.getName())
                        .append(" ----")
                        .append(System.lineSeparator());
                EnumerablePropertySource<?> enumerablePropertySource = (EnumerablePropertySource<?>) propertySource;
                Arrays.stream(enumerablePropertySource.getPropertyNames()).sorted().forEach(propertyName -> {
                    processPropertyName(enumerablePropertySource, propertyName, probe);
                    knownPropertyNames.add(propertyName);
                });
            } else {
                probe.append("---- ").append(propertySource.getName())
                        .append(" [no enumerable properties] ----")
                        .append(System.lineSeparator());
            }
        });

        showOverriddenProperties(probe, knownPropertyNames);
    }

    /*
--- properties OVERRIDDEN report ---
java.home=/home/gclaybur/.sdkman/candidates/java/8.0.282-zulu/jre (from configurationProperties)
  java.home=/home/gclaybur/.sdkman/candidates/java/8.0.282-zulu/jre (from systemProperties)
    java.home=/home/gclaybur/.sdkman/candidates/java/current (from systemEnvironment)
server.port=8777 (from configurationProperties)
  server.port=8777 (from systemEnvironment)
    server.port=1234 (from Config resource 'class path resource [application.properties]' via location 'optional:classpath:/')
     */
    private void showOverriddenProperties(StringBuilder probe, List<String> knownPropertyNames) {
        probe.append(System.lineSeparator());
        probe.append("--- properties OVERRIDDEN report ---").append(System.lineSeparator());
        knownPropertyNames.stream().sorted().distinct().forEach(propertyName -> {
            try {
                String resolvedValue = environment.getProperty(propertyName);
                StringBuilder possiblyOverriddenBuilder = new StringBuilder();
                final String[] indent = {""};
                final boolean[] propertyNameIsOverridden = {false};
                environment.getPropertySources().forEach(propertySource -> {
                    if (propertySource.getProperty(propertyName) != null) {
                        possiblyOverriddenBuilder.append(indent[0])
                                .append(propertyName).append("=")
                                .append(propertySource.getProperty(propertyName))
                                .append(" (from ").append(propertySource.getName())
                                .append(")").append(System.lineSeparator());
                        indent[0] = indent[0] + "  ";
                        propertyNameIsOverridden[0] = !propertySource.getProperty(propertyName).equals(resolvedValue);
                    }
                });
                if (propertyNameIsOverridden[0]) {
                    probe.append(possiblyOverriddenBuilder);
                }
            } catch (IllegalArgumentException ignored) {
                //environment.getProperty(String) can cause this with
                // complex bash ENV, but unparsable by spring
            }
        });
    }

    private void processPropertyName(EnumerablePropertySource<?> propertySource, String propertyName, StringBuilder probe) {
        String sourceProperty = null;
        String resolvedProperty;
        //todo getProperty(string) returns Object sometimes?
        Object property = propertySource.getProperty(propertyName);
        if (property != null) {
            sourceProperty = property.toString();
        }
        resolvedProperty = overriddenPropertyValue(propertyName, sourceProperty);
        if (resolvedProperty != null) {
            probe.append(propertyName).append("=").append(sourceProperty)
                    .append(" OVERRIDDEN to ").append(resolvedProperty)
                    .append(System.lineSeparator());
            // this overridden check will not catch propertyName converted from systemEnvironment
        } else {
            probe.append(propertyName).append("=").append(sourceProperty)
                    .append(System.lineSeparator());
        }
    }

    private String overriddenPropertyValue(String propertyName, String sourceProperty) {
        String resolvedProperty = null;
        try {
            resolvedProperty = environment.getProperty(propertyName);
            if (resolvedProperty != null) {
                if (resolvedProperty.equals(sourceProperty)) {
                    resolvedProperty = null;
                }
            }
        } catch (IllegalArgumentException ignored) {
            /*
            We can't resolve the property from environment.
            This can occur if the ENV has a complex but valid bash env variable
            In that case we don't care to check if the value was overridden.
            e.g.  see Webwar244ApplicationTests.java
             */
        }
        return resolvedProperty;
    }

    public void dumpStartupCommandJVMargs(StringBuilder probeOut) {
        probeOut.append("  JVM args/classloader URLs/startup command").append(System.lineSeparator());
        ManagementFactory.getRuntimeMXBean().getInputArguments().forEach(arg ->
                probeOut.append("JVM arg: ").append(arg).append(System.lineSeparator()));
        if (WhatsUpProbes.class.getClassLoader() instanceof URLClassLoader) {
            Arrays.stream(((URLClassLoader) WhatsUpProbes.class.getClassLoader()).getURLs()).forEach(url -> probeOut.append("classloader.URL: ").append(url).append(System.lineSeparator()));
            // e.g. when running with tomcat:
            // classloader.URL: file:/home/springboot/app/BOOT-INF/lib/log4j-api-2.13.3.jar
            // e.g. when running in docker but not a web app:
            // classloader.URL: jar:file:/home/springboot/app/BOOT-INF/lib/spring-core-4.3.24.RELEASE.jar!/
        } else {
            String classpath = System.getProperty("java.class.path");
            Arrays.stream(classpath.split(":")).forEach(cpEntry ->
                    probeOut.append("classpath: ").append(cpEntry).append(System.lineSeparator()));
        }

        String javaCmd = System.getProperty("sun.java.command");
        probeOut.append("Java command: ").append(javaCmd).append(System.lineSeparator());
        probeOut.append("Main: ").append(getMain("unknown")).append(System.lineSeparator());
        /*
        example Java command output
$ ./gradlew -Dupbanner.debug=true bootRun
Java command: com.garyclayburg.upbannerdemo.UpbannerdemoApplication
Main: UpbannerdemoApplication

$ java -jar build/libs/upbannerdemo-0.0.1-SNAPSHOT.jar --upbanner.debug=true
Java command: build/libs/upbannerdemo-0.0.1-SNAPSHOT.jar --upbanner.debug=true
Main: UpbannerdemoApplication

run upbannerdemo from IntelliJ
Java command: com.garyclayburg.upbannerdemo.UpbannerdemoApplication --server.port=8881
Main: UpbannerdemoApplication

docker image created from preparedocker gradle plugin
$ docker run registry:5000/upbannerdemo:latest --upbanner.debug=true
Java command: org.springframework.boot.loader.JarLauncher --upbanner.debug=true
Main: UpbannerdemoApplication

docker image created from jib/jhipster
$ docker run --rm -v /home/gclaybur/dev/groovyrundemo:/groovy -e GROOVYSCRIPT_HOME=/groovy -e JAVA_OPTS="-Dupbanner.debug=true" -p 10001:8080 rungroovy:latest
Java command: com.garyclayburg.rungroovy.RungroovyApp
Main: RungroovyApp

docker images created from spring boot:
$ ./gradlew clean build buildImage bootBuildImage && docker run docker.io/library/upbannerdemo:0.0.1-SNAPSHOT  --upbanner.debug=true
Java command: org.springframework.boot.loader.JarLauncher --upbanner.debug=true
Main: UpbannerdemoApplication

         */
    }

    void setApplicationName(String applicationName) {
        this.applicationName = convertStartClass(applicationName);
    }

    /**
     * @return The name of the running spring boot application.  Normally this is the name of the class passed
     * to {@link org.springframework.boot.SpringApplication}
     */
    public String getApplicationName() {
        return applicationName;
    }

    void setListeningPort(int listeningPort) {
        this.listeningPort = listeningPort;
    }

    /**
     * @return the number of the TCP port the app is listening to, or 0 if the app is not (yet) listening on any port
     */
    public int getListeningPort() {
        return listeningPort;
    }

    /**
     * Print the default up banner to the logging system.  Normally, this is configured
     * via logback or similar to print the banner to the console.
     * <br>Some banner examples:
     * <br><br>
     * This is a very basic web application that listens on standard port 8080.  Any of the URLs shown
     * can be used to access the app:
     * <pre>
     * ----------------------------------------------------------------------------------------------------
     *     WebJar244Application is UP!
     *     Local:      http://localhost:8080
     *     External:   http://127.0.1.1:8080
     *     Host:       http://gary-XPS-13-9360:8080
     *       Running on JVM: Oracle Corporation Java HotSpot(TM) 64-Bit Server VM 1.8.0_201
     * ----------------------------------------------------------------------------------------------------
     * </pre>
     * <p>
     * This is another basic app that is also configured to use Spring Data MongoDB
     * <pre>
     * ----------------------------------------------------------------------------------------------------
     *     Mongo244Application is UP!
     *     Local:      http://localhost:7349
     *     External:   http://127.0.1.1:7349
     *     Host:       http://gary-XPS-13-9360:7349
     *       Running on JVM: Oracle Corporation Java HotSpot(TM) 64-Bit Server VM 1.8.0_201
     *       Using MongoClient mongodb://localhost:27017/test
     * ----------------------------------------------------------------------------------------------------
     * </pre>
     * <p>
     * This app creates a git.properties file during the build, uses a custom mongo uri and a version number
     * <pre>
     * ----------------------------------------------------------------------------------------------------
     *     scimedit1:0.0.1-SNAPSHOT is UP!               git.commit.time:   2020-01-28T10:32:29-0700
     *     Local:      http://localhost:8050             git.build.version: 0.0.1-SNAPSHOT
     *     External:   http://127.0.1.1:8050             git.commit.id:     3f429cf1cd933897ce1cb3ed6179df371e3ac36b
     *     Host:       http://gary-XPS-13-9360:8050      git.remote.origin: ssh://git@scranton2:2233/home/git/scimedit1.git
     *       Running on JVM: Oracle Corporation Java HotSpot(TM) 64-Bit Server VM 1.8.0_201
     *       Using mongodb uri: mongodb://localhost:27017
     * ----------------------------------------------------------------------------------------------------
     * </pre>
     * This one is from an app that uses https.  There is no version number since the app is running in an IDE.
     * <pre>
     * ----------------------------------------------------------------------------------------------------
     *     memuser is UP!
     *     Local:      https://localhost:8443
     *     External:   https://127.0.1.1:8443
     *     Host:       https://gary-XPS-13-9360:8443
     *       Running on JVM: Oracle Corporation Java HotSpot(TM) 64-Bit Server VM 1.8.0_201
     *       Using mongodb uri: mongodb://patonsynconsoleuser:xxxx@yale.garyclayburg.com:27017/patonsynconsoledb
     * ----------------------------------------------------------------------------------------------------
     * </pre>
     * This one is from running the same app as a spring boot jar file - but without https:
     * <pre>
     * ----------------------------------------------------------------------------------------------------
     *     memuser:0.8.1-SNAPSHOT is UP!                 git.commit.time:   2021-03-01T16:44-0700
     *     Local:      http://localhost:8080             git.build.version: 0.8.1-SNAPSHOT
     *     External:   http://127.0.1.1:8080             git.commit.id:     5c37e87b9808b38aacf61ea3213df08c30208650
     *     Host:       http://gary-XPS-13-9360:8080      git.remote.origin: ssh://git@scranton2:2233/home/git/memuser.git
     *       Running on JVM: Azul Systems, Inc. OpenJDK 64-Bit Server VM 1.8.0_282
     *       Using mongodb uri: mongodb://patonsynconsoleuser:xxxx@yale.garyclayburg.com:27017/patonsynconsoledb
     * ----------------------------------------------------------------------------------------------------
     * </pre>
     * The same app again, but this time running within a Docker container:
     * <pre>
     * ----------------------------------------------------------------------------------------------------
     *     memuser:0.8.1-SNAPSHOT is UP!                 git.commit.time:   2021-03-01T16:44-0700
     *     Local:      http://localhost:8080             git.build.version: 0.8.1-SNAPSHOT
     *     External:   http://172.17.0.2:8080            git.commit.id:     5c37e87b9808b38aacf61ea3213df08c30208650
     *     Docker:     http://53a3672a80a5:8080          git.remote.origin: ssh://git@scranton2:2233/home/git/memuser.git
     *       Running on JVM: Oracle Corporation OpenJDK 64-Bit Server VM 1.8.0_151
     *       Using mongodb uri: mongodb://patonsynconsoleuser:xxxx@yale.garyclayburg.com:27017/patonsynconsoledb
     * ----------------------------------------------------------------------------------------------------
     * </pre>
     * The hostname of the Docker: URL is the hostname of the docker container and will only be accessible to
     * other containers running on the same network.  The External: URL may be accessible from the host where
     * this docker container is being run, depending on your OS.  As with any docker container, you will still
     * need to map this port to a port available on the host if you want to access this application from another
     * host.  Since upbanner runs as a dependency of your application, it has no visibility of what or any ports
     * are mapped this way.
     *
     * @see <a href="https://docs.docker.com/">docker documentation</a>
     */
    public void printDefaultBanner() {
        extraLinePrinterList.add(0, new MongoUpContributor(this, context));
        extraLinePrinterList.add(0, stringBuilder -> stringBuilder.append("      Running on JVM: ")
                .append(getEnvironmentPropertyPrintable("java.vm.vendor"))
                .append(" ")
                .append(getEnvironmentPropertyPrintable("java.vm.name"))
                .append(" ")
                .append(getEnvironmentPropertyPrintable("java.version"))
                .append(System.lineSeparator()));
        printHostPortVersionGitBanner(stringBuilder -> {
        });
    }

    public void printHostPortVersionGitBanner(ExtraLinePrinter extraLinePrinter) {
        if (upbannerSettings.isShowBanner() && isWebAppUp()) {
            StringBuilder stringBuilder = buildBanner(extraLinePrinter);
            log.info(stringBuilder.toString());
        }
    }

    StringBuilder buildBanner() {
        return buildBanner(extraLinePrinter -> {
        });
    }

    StringBuilder buildBanner(ExtraLinePrinter lastExtraLinePrinter) {
        StringBuilder stringBuilder = new StringBuilder("\n----------------------------------------------------------------------------------------------------\n");
        fillHostPortVersionGitBanner(stringBuilder);
        extraLinePrinterList.forEach(extraLinePrinter -> extraLinePrinter.call(stringBuilder));
        lastExtraLinePrinter.call(stringBuilder);
        stringBuilder.append("----------------------------------------------------------------------------------------------------");
        return stringBuilder;
    }

    private void fillHostPortVersionGitBanner(StringBuilder banner) {
        String hostAddress = "unknown host";
        String hostName = "unknown host";
        try {
            hostAddress = InetAddress.getLocalHost().getHostAddress();
            hostName = InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException ignored) {
        }

        Properties gitProperties = loadGitProperties();

        String proto = getProtocol();
        String c1r1 = String.format("%s is UP!", getAppNameVersion());
        String c1r2 = String.format("Local:      %s://localhost:%s", proto, listeningPort);
        String c1r3 = String.format("External:   %s://%s:%s ", proto, hostAddress, listeningPort);
        String c1r4 = String.format("Host:       %s://%s:%s ", proto, hostName, listeningPort);
        if (isDocker()) {
            c1r4 = String.format("Docker:     %s://%s:%s ", proto, hostName, listeningPort);
        } else if (isKubernetes()) {
            c1r4 = String.format("Kubernetes: %s://%s:%s ", proto, hostName, listeningPort);
        }
        String c2r1 = String.format("git.commit.time:   %s", gitProperties.getProperty("git.commit.time"));
        String c2r2 = String.format("git.build.version: %s", gitProperties.getProperty("git.build.version"));
        String c2r3 = String.format("git.commit.id:     %s", gitProperties.getProperty("git.commit.id"));
        String c2r4 = String.format("git.remote.origin: %s", gitProperties.getProperty("git.remote.origin.url"));
        String c3r1 = String.format("build-date: %s", getBuildProp("org.label-schema.build-date"));
        String c3r2 = String.format("vcs-ref: %s", getBuildProp("org.label-schema.vcs-ref"));
        String c3r3 = String.format("vcs-url: %s", getBuildProp("org.label-schema.vcs-url"));
        String c3r4 = String.format("description: %s", getBuildProp("org.label-schema.description"));

        if (getBuildProp("org.label-schema.build-date").equals("development") ||
            getBuildProp("org.label-schema.build-date").equals("unknown")) {
            //skip showing the org.label.* values if they have not been generated by the build
            if (gitProperties.size() == 0) {
                banner.append(String.format("    %-45s\n", c1r1));
                banner.append(String.format("    %-45s\n", c1r2));
                banner.append(String.format("    %-45s\n", c1r3));
                banner.append(String.format("    %-45s\n", c1r4));
            } else {
                banner.append(String.format("    %-45s %s\n", c1r1, c2r1));
                banner.append(String.format("    %-45s %s\n", c1r2, c2r2));
                banner.append(String.format("    %-45s %s\n", c1r3, c2r3));
                banner.append(String.format("    %-45s %s\n", c1r4, c2r4));
            }
        } else {
            banner.append(String.format("    %-45s %-60s %s\n", c1r1, c2r1, c3r1));
            banner.append(String.format("    %-45s %-60s %s\n", c1r2, c2r2, c3r2));
            banner.append(String.format("    %-45s %-60s %s\n", c1r3, c2r3, c3r3));
            banner.append(String.format("    %-45s %-60s %s\n", c1r4, c2r4, c3r4));
        }
    }

    /**
     * @return true, if we are running as a web app AND the lifecycle of the app has reached the point where it is listening on a TCP port
     */
    public boolean isWebAppUp() {
        return listeningPort != 0;
    }

    /**
     * This generates a URL of the web app running on localhost.  When doing so,
     * it considers:
     * <ul>
     *     <li>if the app is using http or https</li>
     *     <li>the IP address of localhost</li>
     *     <li>the port number</li>
     * </ul>
     * On some systems, such as debian or ubuntu, this URL generated might also be
     * usable on the host outside of a docker container without needing to explicitly map
     * the TCP ports when launching the docker container.
     *
     * @return A URL to be used in a browser to access the web app from any host on the
     * network
     */
    public String getExternalURL() {
        String hostAddress = "unknownHost";
        try {
            hostAddress = InetAddress.getLocalHost().getHostAddress();
        } catch (UnknownHostException ignored) {
        }
        return getProtocol() + "://" + hostAddress + ":" + listeningPort;
    }

    /**
     * Returns values from the git.properties file found in the classpath
     *
     * @param gitPropertyName the name of the property contained in git.properties file
     * @return The value, or null if the key does not exist
     */
    public String getGitProperty(String gitPropertyName) {
        if (gitPropertyName == null) {
            return null;
        }
        Properties properties = loadGitProperties();
        return properties.getProperty(gitPropertyName);
    }

    /**
     * @param name the name of the property in build-info.properties
     * @return the property value, or null if it does not exist
     */
    public String getBuildProperty(String name) {
        if (name == null) {
            return null;
        }
        return buildProperties.get(name);
    }

    /**
     * @return true if the app is running within a docker container, false otherwise
     */
    public boolean isDocker() {
        boolean isDocker = false;
        try {
            isDocker = Files.lines(Paths.get(CGROUP_FILE)).map(line ->
                    line.matches(".*/docker.*")).reduce(false, (first, found) -> found || first);
        } catch (IOException e) {
            // not linux?
        }
        return isDocker;
    }

    /**
     * @return true if the app is running within a kubernetes environment, false otherwise
     */
    public boolean isKubernetes() {
        boolean isKubernetes = false;
        try {
            //todo is this consistent with https://docs.spring.io/spring-boot/docs/current/reference/html/deployment.html#cloud-deployment-kubernetes ?
            isKubernetes = Files.lines(Paths.get(CGROUP_FILE)).map(line ->
                    line.matches(".*/kubepod.*")).reduce(false, (first, found) -> found || first);
        } catch (IOException e) {
            // not linux?
        }
        return isKubernetes;
    }

    /**
     * This is the value of the external property "upbanner.show-banner"
     *
     * @return true if the the banner is enabled, false otherwise
     */
    public boolean isShowBanner() {
        return upbannerSettings.isShowBanner();
    }

    /**
     * This is the value of the external property "upbanner.debug"
     *
     * @return true if the debug banner is to be shown, false otherwise
     */
    public boolean isDebug() {
        return upbannerSettings.isDebug();
    }

    /**
     * Registers an implementation of {@link ExtraLinePrinter} to print extra
     * lines as part of the up banner.  e.g.:
     * <br>
     * <pre>{@code
     * whatsUpProbes.registerUpContributor(stringBuilder -> stringBuilder.append("live long and prosper"));
     * }
     * </pre>
     *
     * @param upContributor an implementation of {@link ExtraLinePrinter}
     */
    public void registerUpContributor(ExtraLinePrinter upContributor) {
        extraLinePrinterList.add(upContributor);
    }
}
